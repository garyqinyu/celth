<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Generator" CONTENT="Microsoft Word 97">
   <META NAME="subject" CONTENT="Product brief">
   <META NAME="Template" CONTENT="C:\msoffice\Templates\Letters & Faxes\swelsoft.dot">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (WinNT; I) [Netscape]">
   <TITLE>P E G</TITLE>
</HEAD>
<BODY>
&nbsp;

<P>&nbsp;
<CENTER><IMG SRC="tmpeg.jpg" HEIGHT=82 WIDTH=239></CENTER>

<CENTER><B><I><FONT COLOR="#800000"><FONT SIZE=+4>Portable Embedded GUI</FONT></FONT></I></B></CENTER>

<CENTER><FONT SIZE=+2>&nbsp;</FONT></CENTER>

<CENTER><B><FONT COLOR="#800000"><FONT SIZE=+2>Product Brief</FONT></FONT></B></CENTER>


<P><I>&nbsp;</I>

<P><I>&nbsp;</I>

<P><I>&nbsp;</I>

<P><I>&nbsp;</I>

<P><I>&nbsp;</I>

<P><I>&nbsp;</I>

<P><I>&nbsp;</I>
<CENTER>&nbsp;</CENTER>

<CENTER><FONT FACE="Braggadocio">&copy;</FONT> Copyright 1998,1999,2000</CENTER>

<CENTER>Swell Software, Inc.</CENTER>

<CENTER>3022 Lindsay Lane</CENTER>

<CENTER>Port Huron, MI 48060</CENTER>

<CENTER>Voice: (810) 982-5955</CENTER>

<CENTER>Fax: (810) 982-5949</CENTER>

<CENTER>Email: info@swellsoftware.com</CENTER>

<CENTER>www.swellsoftware.com</CENTER>

<CENTER>All rights reserved</CENTER>


<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>&nbsp;</FONT></FONT></FONT></B>

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>_______________________________________________________</FONT></FONT></FONT></B>
<CENTER><I><FONT COLOR="#800000">Quality Software For Embedded Systems.</FONT></I></CENTER>


<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>&nbsp;</FONT></FONT></FONT></B>

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>Summary</FONT></FONT></FONT></B>

<P>The PEG&amp;trade; (<U>P</U>ortable <U>E</U>mbedded <U>G</U>UI) library
is a professional quality graphical user interface library created to meet
the needs of embedded systems developers. Unlike the alternatives, PEG
is small, fast, and easily ported to virtually any hardware configuration
capable of supporting graphical output. PEG also delivers exceptional visual
appeal and an intuitive and powerful API for application-level user interface
development.

<P>PEG simply provides the most complete GUI solution available to real-time
embedded systems developers. All of the utilities, documentation, support,
and development tools you will require for creating a graphical user interface
on an embedded system are included with the PEG library development package.

<P>PEG is not an operating system, but instead is designed from the ground
up to work seamlessly in a real-time multitasking environment. PEG allows
you to choose the real-time operating system which best meets your needs
and provides the tools, API, and class library that will allow you to quickly
create an outstanding graphical presentation.

<P>PEG is licensed on a per-developed-product basis, eliminating royalty
fees. PEG is delivered with full source code, many example application
programs, a complete set of supporting utility programs, hardware interface
objects for several common video configurations and input devices, and
very thorough documentation to simplify the integration process.

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>Features</FONT></FONT></FONT></B>

<P><B><I><FONT FACE="Arial">Programming Model</FONT></I></B>

<P>The PEG library is written entirely in C++ and implements an event-driven
programming paradigm at the application level. The event-driven paradigm
has proven to be a superior method for creating user interface software,
providing structure and order to the otherwise difficult task of responding
to external system events arriving asynchronously from many sources. This
programming model has the added benefit of being easily integrated into
real-time multitasking environments.

<P><B><I><FONT FACE="Arial">Reduced Size</FONT></I></B>

<P>PEG achieves a small footprint through several means, including heavy
reliance on C++ inheritance to encourage code re-use. Each control type
is built incrementally upon its predecessor, allowing you to select and
use only the objects which meet your requirements without forcing you to
carry along any unneeded baggage. In addition, PEG is written with the
embedded market firmly in mind, meaning that the value of every feature
is weighed against the code size and performance requirements of that feature.

<P>In addition the PEG library is configured at compile time to include
only the features your application requires. A large set of configuration
flags allow you to completely define the set of input devices, drawing
primitives, and many higher level features that your target will require.
This configuration capability allows you to remove at compile time any
library features that your application does not require, in essence allowing
you to customize the library to exactly meet your needs.

<P>A minimum PEG footprint requires roughly 50K of code space, 4K of stack,
and 2K of dynamic memory. A typical full-featured GUI requires a PEG footprint
of roughly 100K code, 4K Stack, and 8K of dynamic memory.

<P><B><I><FONT FACE="Arial">Maximum Performance</FONT></I></B>

<P>PEG achieves maximum performance by minimizing the system overhead required
to maintain a graphical presentation. This includes support for advanced
window and viewport clipping techniques that prevent unnecessary screen
drawing. In addition, PEG always interacts directly with video and input
hardware to achieve the greatest possible throughput.

<P><B><I><FONT FACE="Arial">Highly Portable</FONT></I></B>

<P>PEG achieves portability primarily by abstracting all hardware dependent
functionality. The vast majority of the PEG library is completely hardware
independent, relying on well-defined hardware interface objects to provide
a consistent, simple, and reliable set of I/O methods. PEG applications
are running today on all of the most common embedded processors including
x86, ARM, PowerPC, MIPS, StrongARM, ColdFire, and CPU32 based microprocessors.
Several working examples supporting the most common display and input types
are provided with the library.

<P>Portability is further achieved by making no assumptions about the software
environment. OS-specific dependencies are encapsulated and well documented,
allowing users to follow the examples provided to create new interface
classes for any environment. PEG further avoids the use of intrinsic data
types and floating point math to eliminate problems associated with CPU
word length differences and the common lack of floating point support

<P>Finally, portability is increased through general conformity to the
EC++ standard. PEG does not require support for C++ exception handling
or run-time type identification. The application level software can, of
course, make use of these features if they are supported in the target
environment. PEG is fully verified with a large set of embedded CPU compilers
(below).

<P><B><I><FONT FACE="Arial">Flexible and Powerful API</FONT></I></B>

<P>The PEG library provides an intuitive and robust object hierarchy. Objects
may be used directly as provided, or enhanced through user derivation.
PEG imposes no artificial limits on how objects are used, meaning that
the user is free to design screens with an indefinite nesting level of
controls within windows within other windows. You will find that you can
do things very quickly and easily with PEG -- things that would be very
difficult and time-consuming using the mainstream desktop GUI programming
environments.

<P>The default appearance of PEG objects is almost identical to the common
desktop graphical environments. This appearance can, of course, be enhanced
or simplified to fit the requirements of the application. In fact users
often prefer to create a user interface with a very custom appearance and
no resemblance to the desktop graphical environments. This is also readily
accommodated within the design of PEG.

<P>The PEG API is defined entirely by the public functions provided by
the library classes. This API provides robust and intuitive methods for
performing even very complex graphical operations. We encourage you to
obtain an evaluation copy of the library and experiment with PEG to insure
that the library meets your project’s requirements.

<P><B><I><FONT FACE="Arial">Real-Time Awareness:</FONT></I></B>

<P>PEG is fully integrated with RTOS messaging, memory management, and
synchronization services. This yields the lowest possible overhead and
the only true real-time multi-tasking GUI environment available. PEG input
devices are interrupt driven, and again use RTOS services to communicate
user input information to the graphical user interface.

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>Development
Environments</FONT></FONT></FONT></B>

<P><B><I><FONT FACE="Arial">Microsoft Windows Development Environment</FONT></I></B>

<P>Very often during the early stages of an embedded development effort,
it is difficult or impossible to do software testing and debugging on the
intended target platform. For this reason PEG provides a set of hardware
and OS encapsulation classes which allow your PEG user interface to run
as a standard 32-bit Windows application. <B><I>You can create, test, and
debug your entire user interface while using the very mature Windows application
development tools</I></B>. Once your target platform is available, you
simply have to replace the PEG interface encapsulation classes with versions
written for your target.

<P><B><I><FONT FACE="Arial">MS-DOS Development Environment</FONT></I></B>

<P>Building on the above concept, PEG also comes complete with interface
classes for running PEG as a DOS real-mode, 16-bit protected mode, or 32-bit
flat mode application program. This is often an advantage for users who
intend to use some form of x86 CPU on the final target system. Porting
to the final target is again simply a matter of rebuilding the PEG library
with I/O interface classes designed for your target. Your application level
GUI software is guaranteed to run without modification on the target platform.

<P><B><I><FONT FACE="Arial">X11 Development Environment</FONT></I></B>

<P>Similar in functionality to the Microsoft Windows Development Environment,
the X11 Development Environment allows you to code, test and debug your
application while running your application on the X11 Windowing System.
The added advantage of this environment is that you may be running X11
on top of the same OS that acts as your embedded OS. This allows you to
have a clear representation of your final application running on it’s target
OS while still having access to all of your desktop tools. Again, porting
to your final target is simply a matter of recompiling the PEG library
with I/O interface classes designed for your target.

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>Multi-Tasking
Models</FONT></FONT></FONT></B>

<P>PEG supports two tasking models to meet the needs of your embedded system.
In the first model, PEG is configured to execute as a single low-priority
task in the overall multi-tasking system. In this configuration the user
interface software interacts with I/O devices and other system tasks via
messaging methods supported by the underlying OS kernel. This model has
the advantage of insulating the user-interface software from the real-time
tasks executing on the target CPU, and guarantees that PEG does not have
any effect on the real-time performance of the target system.

<P>PEG may also be configured to support multiple GUI tasks. These tasks
can be of differing priorities and can each <B><U>directly</U></B> create,
display, and control any number of GUI windows or child controls. <B><U>This
advanced capability is unique to the design of PEG</U></B>. In this configuration,
PEG protects internal data structures from corruption through judicial
use of semaphores, which again are provide by the underlying OS. This tasking
model has several advantages, the most significant being that the application
level programming is greatly simplified. At any time any task in the system
can directly display a window or any other type of GUI object and update
the information displayed within that object.

<P>Finally, PEG can also be run standalone without a multitasking kernel.
This model is most often used in smaller, less complex applications.

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>Compiler Support</FONT></FONT></FONT></B>

<P>The PEG library has been fully verified with each of the following compilers:
<UL>
<LI>
Green Hills for ARM/StrongARM</LI>

<LI>
Green Hills for PowerPC</LI>

<LI>
Green Hills for SH3</LI>

<LI>
DiabData for PowerPC and ColdFire</LI>

<LI>
CAD-UL for x86 32-bit</LI>

<LI>
Microsoft MSVC++ 1.52, 5.0, and 6.0, real and protected modes.</LI>

<LI>
Borland 4.52 and 5.0, real and protected modes.</LI>

<LI>
MetaWare for x86 32-bit</LI>

<LI>
MetaWare for ARM</LI>

<LI>
Watcom x86 real mode</LI>

<LI>
Watcom x86 32-bit protected mode</LI>

<LI>
Tasking for C167</LI>

<LI>
ARM ADS 1.0 for ARM</LI>

<LI>
GCC for all Unix/Linux environments</LI>
</UL>
&nbsp;

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>Input Devices</FONT></FONT></FONT></B>

<P><B><FONT FACE="Arial">Pointing Device</FONT></B>

<P>PEG includes complete support for mouse, joystick, and/or touch screen
input. This includes drawing various pointer bitmaps or using hardware
cursor capabilities. Complete mouse input drivers and touch screen input
drivers are provided for each of the reference platforms. All pointer input
functionality can also be removed from the library simply by turning off
a library configuration flag prior to compiling the library.

<P>When operating with a touch screen, PEG can be configured to eliminate
drawing of the mouse pointer and can also be configured not to highlight
the object that has input focus. These options further reduce code size
and drawing overhead when running with touch screen input. When running
with a touch screen PEG also eliminates the need for "pointer move" messages
and thus all operations and controls work normally with only touch and
release input messages. This feature simplifies touch screen input driver
development.

<P><B><FONT FACE="Arial">Keyboard/Keypad</FONT></B>

<P>Full keyboard support is optionally included in the PEG library. This
includes all handling required for keyboard navigation through menus, windows,
and dialogs. Keyboard support may range from a full QWERTY keyboard to
a small set of user-defined membrane keys. Full navigation and operation
can be accomplished with as few as three unique input keys.

<P><B><FONT FACE="Arial">Soft Keys</FONT></B>

<P>Using soft keys, i.e. membrane keys placed at the perimeter of the display
screen, is also supported. When using soft keys, the system programmer
configures PEG to operate as with a touch screen, and sends to PEG touch-screen
click messages corresponding to the screen position adjacent to each membrane
key. In this way PEG is ‘fooled’ into working as if a normal mouse or touch
screen were present. Many other types of input devices can also be used
by following a similar approach.

<P>&nbsp;

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>Language Support</FONT></FONT></FONT></B>

<P>PEG provides industry leading support for multi-lingual applications.
PEG fully supports two-byte characters and Unicode string encoding. Our
<B><I>CompositeFont</I></B> technology provides an industry-leading solution
for incorporating even very large character sets in memory-limited embedded
systems. Virtually any language can be supported using any combination
of character sets including Latin, Cyrillic, Han, Katakana, Hiragana, etc.,
in a single PEG application. This capablity gives the system developer
unequaled range and flexibility in designing products for foreign markets.

<P>The PEG library provides a full complement of compiler-independent ‘C’
string library functions, eliminating the need for any special non-ANSI
compiler support for 2-byte characters.

<P>PEG also provides complete string table editing and maintenance capabilities.
System developers use this feature to enter and edit all strings for all
supported languages. The PEG <B><I>String Table Editor</I></B> allows you
to edit a string in any language using only a mouse or Latin (ASCII) keyboard.
<B>JIS</B> and <B>Unicode</B> data entry formats are also supported. The
String Table Editor exports your system strings in a unique source file
while at the same time mapping each string to the character set or character
sets you have specified for you target system.
<BR><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>Control Types</FONT></FONT></FONT></B>

<P>PEG supports a rich and growing compliment of GUI object types including:
<TABLE BORDER=0 COLS=2 WIDTH="90%" >
<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegAnimationWindow</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegMinimizeButton</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegBitmap</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegMLTButton</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegBitmapButton</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegMultiLineChart</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegBitmapConvert</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegNotebook</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegBitmapLight</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegPointer</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegButton</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegProgressBar</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegCheckBox</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegProgressWindow</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegComboBox</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegPrompt</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegDecoratedWindow</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegRadioButton</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegDial</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegRect</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegDialog</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegScale</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegEditBox</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegSlider</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegFiniteDial</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegSpinButton</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegFiniteBitmapDial</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegSpreadSheet</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegFont</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegStatusBar</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegGroup</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegString</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegGifConvert</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegStripChart</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegHorizontalScrollBar</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegSystemButton</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegHorizontalList</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegTable</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegIcon</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegTerminalWindow</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegImageConvert</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegTextBox</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegJpgConvert</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegTextButton</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegLight</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegThing</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegLinearScale</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegTitle</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegLinearBitmapScale</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegToolbar</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegLineChart</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegToolbarPanel</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegList</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegTreeNode</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegMaximizeButton</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegTreeView</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegMenu</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegVerticalList</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegMenuBar</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegVerticalPrompt</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegMenuButton</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegVerticalScrollBar</FONT></B></LI>
</UL>
</TD>
</TR>

<TR>
<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegMessageWindow</FONT></B></LI>
</UL>
</TD>

<TD>
<UL>
<LI>
<B><FONT FACE="ARIAL">PegWindow</FONT></B></LI>
</UL>
</TD>
</TR>
</TABLE>
<B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>&nbsp;</FONT></FONT></FONT></B>

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>Video Output</FONT></FONT></FONT></B>

<P><B><FONT FACE="Arial">Overview</FONT></B>

<P>PEG is designed work with and take full advantage a broad range of video
output devices and display screens. PEG can be configured for monochrome,
4 grays, 16 grays, 16 colors, 256 colors, 65535 colors, and true 24-bit
RGB color output. Further, the output color depth may be defined at compile
time (producing the smallest code) or at run time (allowing the video output
device to be determined during system initialization).

<P>A full range of VGA and LCD display devices are supported, including
LCD devices of unique x-y resolutions or orientations. The design of the
PEG display drivers enables common resolutions such as 640x480 VGA or 320x240
LCD screens to be handled in an identical manner as very unique or very
small x-y pixel resolutions.

<P>All PEG screen interface operations are performed by a library class
named PegScreen. This class defines the drawing primitives and other operations
that are available in every PEG system, regardless of display type or video
controller in use. Specific derived versions of PegScreen are then provided
for each color depth, resolution, and video controller.

<P><B><FONT FACE="Arial">Hardware Acceleration</FONT></B>

<P>PEG takes full advantage of video controllers which support hardware
acceleration capabilities such as hardware cursor or hardware bit-blit.
These capabilities are always provided in the display driver software,
via software emulation when the target controller does not provide a specific
feature directly in hardware. When hardware acceleration is available,
a small set of functions in the display driver are reduced to take advantage
of the video hardware acceleration.

<P><B><FONT FACE="Arial">Double-Buffering</FONT></B>

<P>Double-buffered video output is optionally supported in every PEG configuration.
This configuration allows all intermediate drawing operations to be performed
to an off-screen or local memory buffer. At the conclusion of a drawing
operation, the invalidated region of the local memory buffer is transferred
to the visible video memory, using hardware bit-blitting if provided. This
mode of operation provides flicker-free animation and scrolling. Double-buffered
output, while always supported, is not required. PEG can also be configured
to do all drawing directly to visible video memory.

<P><B><FONT FACE="Arial">&nbsp;</FONT></B>

<P><B><FONT FACE="Arial">Screen Driver Templates</FONT></B>

<P>A full set of screen driver templates are provided for 1-bpp (monochrome)
through 24-bpp (TrueColor RGB) video output. These template drivers are
designed to work with any CPU architecture that supports direct, linear
access to the video memory buffer Examples of such architectures include:
<UL>
<LI>
x86 32-bit flat and protected modes</LI>

<LI>
Motorola ColdFire</LI>

<LI>
ARM and StrongARM</LI>

<LI>
MPC821</LI>

<LI>
MPC823</LI>

<LI>
MIPS</LI>

<LI>
68K</LI>

<LI>
CPU32 based systems (683xx)</LI>

<LI>
AMD Elan</LI>

<LI>
All x86 systems which require &lt;= 64K Bytes of video memory</LI>
</UL>
The screen driver templates are capable of supporting any screen resolution
from 1 x 1 to 65535 x 65535 pixels.

<P>The PEG screen driver templates require that the software developer
provide only three functions to build a complete working GUI:
<OL>
<LI>
GetVideoAddress()- This function must return the base address of the video
frame buffer. The implementation varies depending on architecture and operating
mode.</LI>

<LI>
SetupPalette()- This function must program the controller palette registers
when operating in a palletized mode. For low-end video output devices and
for 16 and 24 bit color output no palette programming is necessary and
this function is not required.</LI>

<LI>
ConfigureController()- This function must configure the video controller
registers to synchronize the controller output signals with the timing
specifications of your display device. Many example configurations for
the most common controllers and display devices are provided with the PEG
library.</LI>
</OL>
<B><FONT FACE="Arial">Accelerated Screen Drivers</FONT></B>

<P>Many embedded controllers such as the Elan, ARM, and PowerPC CPUs provide
integrated video control functionality with limited acceleration features.
These controllers work best using one of the template drivers listed above.

<P>On the other hand, several popular external video controllers are also
applied to embedded applications where higher performance is required.
PegScreen driver classes tuned to take advantage of the hardware acceleration
features of many of these external video controllers are also available.
Customized driver classes are currently available for the following video
controllers:

<P>EPSON SPC8106 VGA LCD/CRT Controller
<BR>EPSON SED1330 LCD Controller
<BR>EPSON SED1353 LCD Controller
<BR>EPSON SED1354 LCD/CRT Controller
<BR>EPSON SED1355 LCD/CRT Controller
<BR>EPSON SED1356 LCD/CRT/TV Controller
<BR>EPSON SED1374 LCD Controller
<BR>EPSON SED1375 LCD Controller

<P>PowerPC823 Integrated LCD Controller

<P>ARM Integrated LCD Controller

<P>Cirrus Logic GD5430 PCI

<P>Chips &amp; Technology 65535
<BR>Chips &amp; Technology 65545
<BR>Chips &amp; Technology 69000/69030

<P>MediaQ MQ200 Accelerated Video Controller

<P>Custom PegScreen drivers for additional video controllers are available
on request.

<P><B><FONT FACE="Arial">Development Environment Screen Drivers</FONT></B>

<P>As stated above, it is often useful to run PEG in a PC development environment
regardless of your final target architecture. This allows software and
hardware development to proceed in parallel, shortening time to market
for a new design. The PEG development package always ships with the following
PegScreen driver classes to facilitate this type of concurrent development:
<UL>
<LI>
Generic VGA- Runs on any PC-compatible in any processor mode.</LI>

<LI>
VESA SuperVGA- Runs on any PC-compatible in real mode</LI>

<LI>
Win32- Runs on any PC-compatible running MS Windows 95, 98, or NT.</LI>

<LI>
X11 – Runs on any PC-compatible running X11 R6 including XFree86 3.3.x</LI>
</UL>
<B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>&nbsp;</FONT></FONT></FONT></B>

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>Drawing Primitives</FONT></FONT></FONT></B>

<P>While PEG applications rely primarily on the provided PEG class library
objects for window and control drawing, it is often useful to perform custom
drawing at the application level. For this reason all PEG drawing primitives
can be invoked at any time by the user’s application level software. The
PEG drawing primitives include:
<BR>&nbsp;
<TABLE BORDER CELLPADDING=7 WIDTH="590" >
<TR>
<TD VALIGN=TOP WIDTH="33%">
<CENTER><B>Function</B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="67%">
<CENTER><B>Comments</B></CENTER>
</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">BeginDraw</TD>

<TD VALIGN=TOP WIDTH="67%">Begins a sequence of drawing operations.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">Bitmap</TD>

<TD VALIGN=TOP WIDTH="67%">Draws a bitmap at the desired location.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">BitmapFill</TD>

<TD VALIGN=TOP WIDTH="67%">Tiles a bitmap to fill a given area.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">Capture&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Captures an area of the screen.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">Circle&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Any color outline or fill, optional fill, any
outline width.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">CreateBitmap</TD>

<TD VALIGN=TOP WIDTH="67%">Used to draw offscreen or for animations.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">DeleteFont</TD>

<TD VALIGN=TOP WIDTH="67%">Delete font created with MakeFont.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">DrawText&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Any color, position, font, transparent background
or fill.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">Ellipse&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Any color border or fill, any outline width.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">EndDraw</TD>

<TD VALIGN=TOP WIDTH="67%">Ends a sequence of drawing operations.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">GetPointerType&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Returns mouse pointer type.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">GetXRes</TD>

<TD VALIGN=TOP WIDTH="67%">Display x resolution, in pixels.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">GetYRes</TD>

<TD VALIGN=TOP WIDTH="67%">Display y resolution, in pixels.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">HidePointer</TD>

<TD VALIGN=TOP WIDTH="67%">Removes the mouse pointer from the screen.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">Invalidate</TD>

<TD VALIGN=TOP WIDTH="67%">Only invalid screen regions may be drawn to.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">Line&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Any width, color, orientation.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">MakeFont&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Create bitmapped font from vector font.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">PatternLine&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Any width, color, orientation, pattern.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">PlotPoint&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Any color.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">Polygon&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Outline and/or fill, any outline width.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">Rectangle</TD>

<TD VALIGN=TOP WIDTH="67%">Outline and/or fill, any outline width.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">RectangleXOR&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Performs logical XOR operation with pixels in
region.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">RectMove</TD>

<TD VALIGN=TOP WIDTH="67%">Used for scrolling and animation.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">ResetPalette</TD>

<TD VALIGN=TOP WIDTH="67%">Restores default palette.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">Restore</TD>

<TD VALIGN=TOP WIDTH="67%">Restore previously captured screen area.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">RestorePointer</TD>

<TD VALIGN=TOP WIDTH="67%">Restores hidden mouse pointer.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">SetPointer&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Sets mouse pointer position</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">SetPointerType&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Sets mouse pointer shape</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">SetPalette&nbsp;</TD>

<TD VALIGN=TOP WIDTH="67%">Allow loading custom palette.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">TextHeight</TD>

<TD VALIGN=TOP WIDTH="67%">Returns height of string in current font, in
pixels.</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="33%">TextWidth</TD>

<TD VALIGN=TOP WIDTH="67%">Returns width of string in current font, in
pixels.</TD>
</TR>
</TABLE>
All drawing primitives enforce object clipping and viewport validation,
thus preventing run-time address errors due to invalid parameters being
passed to drawing functions.

<P>&nbsp;

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>&nbsp;</FONT></FONT></FONT></B>

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>Utilities</FONT></FONT></FONT></B>

<P>PEG is delivered with a full set of utility programs useful for embedded
developers. These utility programs allow you to generate and use your own
fonts, convert and ROM several forms of bitmap images, and design and automatically
generate the source code for your PEG windows and dialogs.

<P>&nbsp;

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>FontCapture</FONT></FONT></FONT></B>

<P>PEG supports two font formats. These include a custom 1-bit-per-pixel
variable-width bitmapped font format and a scalable vector font format.
A scalable vector font is provided with the library and included or removed
based on compile-time configuration flags. The vector font supports any
point size along with normal, bold and italic attributes.

<P><B>FontCapture</B> is a PC executable program, written using PEG, that
allows users to convert TrueType and BDF font files into the native bitmapped
font format required internally by PEG. The output of FontCapture is a
source file containing "C" style data arrays describing the captured font.
These source files are then compiled and linked in with your application,
allowing you to associate any number of custom fonts with any PEG control
type that displays string data. The image below is a screen shot of the
FontCapture utility program.
<CENTER><IMG SRC="image52.gif" HEIGHT=395 WIDTH=343></CENTER>


<P>&nbsp;

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>ImageConvert</FONT></FONT></FONT></B>

<P>ImageConvert is a PC executable program, written using PEG, that converts
.bmp, .gif, and .jpg images into a compressed format supported by the PEG
bitmap functions. The output of PEG Image Convert is a ‘C’ source file
that can then be compiled and linked in with your application. Image Convert
will optionally compress the output bitmaps on an individual basis, allowing
you to achieve the best mix of speed vs size.

<P><B>ImageConvert</B> also creates optimized palettes for applications
running in 4 or 8 bpp mode. The user can input any combination of supported
image files, and <B>ImageConvert<I> </I></B>will perform advanced quantization
and color-reduction producing an optimal palette or palettes corresponding
to the input images. The output images are then automatically re-encoded
using the newly generated palette information. Multiple palettes can be
used in one application. ImageConvert also supports dithering of pixel
color data when reducing the color depth of an input image to match the
output display capabilities. The image below is a screen shot of the ImageConvert
utility program.
<CENTER><IMG SRC="Image53.gif" HEIGHT=448 WIDTH=405></CENTER>


<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>&nbsp;</FONT></FONT></FONT></B>

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>Window Builder</FONT></FONT></FONT></B>

<P>WindowBuilder is a powerful visual design tool created for use with
the PEG library. WindowBuilder allows the developer to quickly create and
use custom windows and dialogs. The output of WindowBuilder is the C++
source code required to create the desired window or dialog. WindowBuilder
also generates the prototype message handling code required to process
signals received from the window or dialog child controls.

<P>WindowBuilder is actually a PEG application program running in the Win32
development environment. This guarantees that the operation of WindowBuilder
is fully and completely WYSIWYG, and your target will appear exactly as
it does in the WindowBuilder environment.

<P>The developer using WindowBuilder can import any number of custom fonts
and apply those fonts to PEG controls using drag-and-drop techniques. The
PEG controls immediately update to use the custom font, and the source
code produced also configures each control to use the font selected.

<P>Likewise any number of graphics files may also be imported into the
WindowBuilder project environment. Imported graphics may be any combination
of .bmp, .jpg, or .gif files. WindowBuilder will re-encode these files,
performing dithering and color reduction if required, to insure that the
graphics are ready to use on the target platform. Imported graphics are
written out to ‘C’ style data arrays, ready to be compiled and linked into
the target system software.

<P>Once a graphic has been imported into the WindowBuilder environment,
it can be applied to any PEG object which supports bitmap decorations.
The source code generated by WindowBuilder will perform all the necessary
steps to create the controls and assign the correct bitmaps to each control.
While in the WindowBuilder environment, the graphics appear on the selected
controls exactly as they will appear on the final target.

<P><B>We strongly believe that Window Builder is simply the most powerful
GUI application development tool available to embedded developers at any
price!</B>

<P>As with all PEG supporting tools, WindowBuilder is essential to making
PEG a complete embedded GUI solution and is therefore included with the
PEG library at no extra charge.

<P>The following is a screen shot of the WindowBuilder application program:

<P><IMG SRC="image56.gif" HEIGHT=505 WIDTH=648>

<P>&nbsp;

<P><B><FONT FACE="Arial"><FONT COLOR="#800000"><FONT SIZE=+1>Requirements</FONT></FONT></FONT></B>

<P>PEG is designed to work with any C++ compiler/debugger combination and
any embedded CPU. Since PEG is provided in source form, you can usually
just compile the PEG source files, generate the PEG library, and link the
library into your target software. Support is provided for any user who
experiences difficulty using PEG with a specific toolset.

<P>For multi-tasking environments, the target real-time operating system
must support means for inter-task communication via messages. In addition,
PEG provides high-level timer services which are only operational if the
underlying OS supports a periodic timer interrupt service. When PEG is
configured to support multiple GUI tasks running at different priorities,
the OS must support means for semaphore protection of critical code sections.
These requirements are trivial in quality commercial real-time operating
systems.

<P>There are no internal restrictions on CPU type or hardware configuration.
Due to performance requirements, however, PEG runs best when using a 16-bit
or better CPU running at 16 MHz or higher. Very high resolution or color
depth also requires better CPU performance in order to achieve a responsive
graphical display.
</BODY>
</HTML>
