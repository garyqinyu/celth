/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
// 13a0scr8.hpp - PegScreen screen driver for Seiko-Epson S1D13A03/4/5
//      controllers using 256 colors.
//
// Author: Jim DeLisle
//
// Copyright (c) 1997-2002 Swell Software 
//              All Rights Reserved.
//
// Unauthorized redistribution of this source code, in whole or part,
// without the express written permission of Swell Software
// is strictly prohibited.
//
// Notes:
//
// This driver has several build options. First, the driver is set up to 
// run in either a PCI or direct connect configuration. If running with a
// PCI configuration (like the S5U13A04BOOB/BOOC eval card), we find the card
// using PCI protocol. If a direct connect (ColdFire, 68K, ARM, other),
// you must define the register and memory addresses.
//
// This driver can also be configured to use double buffering, hardware cursor,
// etc. Please read the comments above each configuration flag.
//
// This driver is meant for use with 256 color systems only. The display can
// be LCD only. If you are using other than 256 colors,
// you should use the driver created for your color depth.
//
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/

#include "string.h"     // for memcpy
#include "stdlib.h"     // for abs
#include "peg.hpp"

// include the header file generated by the Epson provided 13A04cfg
// utility
#include "s1d13a0x.h"

#if defined(USE_PCI)
#include "pegpci.hpp"
#endif

extern UCHAR DefPalette256[];

/*--------------------------------------------------------------------------*/
// The register locations are really the register ID / sizeof(DWORD) since
// all of the video registers, including the BitBlit registers, are
// DWORD size, not bytes. So, instead of doing a sizeof(DWORD) every time
// we write to or read from a register, we'll just make a static here
// and use it. The S1D_VALUE is defined in the s1d13a0x.h header
// file generated by the Epson 13A04cfg utility. Usually, it will be
// an unsigned long, but may vary depending on the platform.
/*--------------------------------------------------------------------------*/
static const gtSizeOfReg = sizeof(S1D_VALUE);

/*--------------------------------------------------------------------------*/
// The register indicies and values are in the s1d13a0x.h header file
// generated by the Epson 13A04cfg utility. This macro will set the
// gaRegVals to point at the S1D_REGS values that the utility wrote.
/*--------------------------------------------------------------------------*/
S1D_INSTANTIATE_REGISTERS(static const, gaRegVals);

/*--------------------------------------------------------------------------*/
// Macro to check the status of the BITBLIT engine.
/*--------------------------------------------------------------------------*/
DWORD gbPreventOptimize;

#define BLIT_CHECK\
    while(mpBitBlitRegs[REG_BB_STATUS / gtSizeOfReg] & 0x0001)\
    {\
        gbPreventOptimize++;\
    }\
    gbPreventOptimize = *mpBitBlitRegs; \


/*--------------------------------------------------------------------------*/
// CreatePegScreen- Called by startup code to instantiate the PegScreen
// class we are going to run with.
/*--------------------------------------------------------------------------*/
PegScreen *CreatePegScreen(void)
{
    PegRect Rect;
    Rect.Set(0, 0, PEG_VIRTUAL_XSIZE - 1, PEG_VIRTUAL_YSIZE - 1);
    PegScreen *pScreen = new S1D13A04Screen(Rect);
    return pScreen;
}

/*--------------------------------------------------------------------------*/
// Constructor- initialize video memory addresses
/*--------------------------------------------------------------------------*/
S1D13A04Screen::S1D13A04Screen(PegRect &Rect) : PegScreen(Rect)
{
    mdNumColors = 256;  

    mwHRes = Rect.Width();
    mwVRes = Rect.Height();

    mpScanPointers = new UCHAR PEGFAR *[Rect.Height()];

    UCHAR PEGFAR *CurrentPtr = GetVideoAddress();

    for (SIGNED iLoop = 0; iLoop < Rect.Height(); iLoop++)
    {
        mpScanPointers[iLoop] = CurrentPtr;
        CurrentPtr += mwHRes;
    }

    mLastPointerPos.x = Rect.Width() / 2;
    mLastPointerPos.y = Rect.Height() / 2;
    mbPointerHidden = FALSE;
    mwDrawNesting = 0;

    ConfigureController();        // Configure Controller Registers

    SetPalette(0, 232, DefPalette256);
}


/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
// GetVideoAddress- Returns the base address of the video frame buffer.
//
// There are different forms of the GetVideoAddress function. These
// different forms are for different operating systems and system architechtures.
//
// When running the SDU1386BOC eval card in a PCI environment, we must
// find the card using PCI BIOS calls. If running in any other environment
// the base address is simply determined by a #define in the 1386 header file.
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
UCHAR PEGFAR *S1D13A04Screen::GetVideoAddress(void)
{
    UCHAR* pMem = NULL;

   #if defined(USE_PCI)

    pMem = PegPCIGetVideoAddress(PEGPCI_VGACLASS, PEGPCI_VENDORID, 
                                 PEGPCI_DEVICEID);
    if(pMem)
    {
        mpVidMemBase = pMem + 0x200000;        // offset 2M for PCI mem
		mpVidRegBase = (DWORD*)pMem;
        mpBitBlitRegs = (DWORD*)pMem;
        pMem = mpVidMemBase;
    }
   
   #else

    // Here for a direct connection. Use pre-defined addresses:

    pMem = (UCHAR *) VID_MEM_BASE;
    mpVidMemBase = pMem;
    mpVidRegBase = (DWORD *) VID_REG_BASE;
    mpBitBlitRegs = (DWORD *) BITBLT_REG_BASE;

   #endif

    mpVidMemBase = pMem;

    #ifdef DOUBLE_BUFFER
     #ifdef LOCAL_BUFFERING
      pMem = new UCHAR[mwHRes * mwVRes];
     #else
      pMem += (DWORD) mwHRes * (DWORD) mwVRes;
     #endif
    #endif

    return (pMem);
}


/*--------------------------------------------------------------------------*/
// Destructor
/*--------------------------------------------------------------------------*/
S1D13A04Screen::~S1D13A04Screen()
{
    delete mpScanPointers;
}

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
void S1D13A04Screen::BeginDraw(PegThing *)
{
    LOCK_PEG        // if multitasking, lock the screen
    if (!mwDrawNesting)
    {
       #if defined(DOUBLE_BUFFER) && !defined(LOCAL_BUFFERING)
        // make sure bit-blit engine is done:

        BLIT_CHECK
        
       #endif

       #if defined(PEG_MOUSE_SUPPORT)
        if (miInvalidCount)
        {
            if (mInvalid.Overlap(mCapture.Pos()))
            {
                HidePointer();
                mbPointerHidden = TRUE;
            }
        }
       #endif
    }

    mwDrawNesting++;
}

/*--------------------------------------------------------------------------*/
void S1D13A04Screen::BeginDraw(PegThing *Caller, PegBitmap *pMap)
{
    if (mbVirtualDraw)
    {
        return;
    }
    LOCK_PEG        // if multitasking, lock the screen

    #if defined(DOUBLE_BUFFER) && !defined(LOCAL_BUFFERING)
    // make sure bit-blit engine is done:

    BLIT_CHECK

    #endif

    mpSaveScanPointers = mpScanPointers;

    WORD wWidth = pMap->wWidth;

    if (IS_SPRITE(pMap))
    {
        if (wWidth & 1)
        {
            wWidth++;
        }
    }

    if (pMap->wHeight && pMap->wWidth && pMap->pStart)
    {
        mpScanPointers = new UCHAR PEGFAR *[pMap->wHeight];
        UCHAR PEGFAR *CurrentPtr = pMap->pStart;
        for (SIGNED iLoop = 0; iLoop < pMap->wHeight; iLoop++)
        {
            mpScanPointers[iLoop] = CurrentPtr;
            CurrentPtr += wWidth;
        }
        mVirtualRect.Set(0, 0, pMap->wWidth - 1, pMap->wHeight - 1);
        mbVirtualDraw = TRUE;
    }
}

/*--------------------------------------------------------------------------*/
void S1D13A04Screen::EndDraw()
{
    mwDrawNesting--;

    if (!mwDrawNesting)
    {
       #if defined(PEG_MOUSE_SUPPORT)
        if (mbPointerHidden)
        {
            SetPointer(mLastPointerPos);
            mbPointerHidden = FALSE;
        }
       #endif

       #ifdef DOUBLE_BUFFER
        MemoryToScreen();
       #endif

        while(miInvalidCount > 0)
        {
            miInvalidCount--;
            UNLOCK_PEG
        }
    }
    UNLOCK_PEG
}

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
void S1D13A04Screen::EndDraw(PegBitmap *pMap)
{
    if (mbVirtualDraw)
    {
        mbVirtualDraw = FALSE;
        delete [] mpScanPointers;
        mpScanPointers = mpSaveScanPointers;
        UNLOCK_PEG
    }
}

/*--------------------------------------------------------------------------*/
// CreateBitmap: The default version creates an 8-bpp bitmap.
/*--------------------------------------------------------------------------*/
PegBitmap *S1D13A04Screen::CreateBitmap(SIGNED wWidth, SIGNED wHeight)
{
    return PegScreen::CreateBitmap(wWidth, wHeight);
}

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
void S1D13A04Screen::LineView(SIGNED wXStart, SIGNED wYStart, SIGNED wXEnd, 
    SIGNED wYEnd, PegRect &Rect, PegColor Color, SIGNED wWidth)
{
    if (wYStart == wYEnd)
    {
        HorizontalLine(Rect.wLeft, Rect.wRight, Rect.wTop, Color.uForeground, wWidth);
        return;
    }
    if (wXStart == wXEnd)
    {
        VerticalLine(Rect.wTop, Rect.wBottom, Rect.wLeft, Color.uForeground, wWidth);
        return;
    }

    SIGNED dx = abs(wXEnd - wXStart);
    SIGNED dy = abs(wYEnd - wYStart);

    if (((dx >= dy && (wXStart > wXEnd)) ||
        ((dy > dx) && wYStart > wYEnd)))
    {
        PEGSWAP(wXEnd, wXStart);
        PEGSWAP(wYEnd, wYStart);
    }

    SIGNED y_sign = ((int) wYEnd - (int) wYStart) / dy;
    SIGNED x_sign = ((int) wXEnd - (int) wXStart) / dx;
    SIGNED decision;

    SIGNED wCurx, wCury, wNextx, wNexty, wpy, wpx;

    if (dx >= dy)
    {
        for (wCurx = wXStart, wCury = wYStart, wNextx = wXEnd,
             wNexty = wYEnd, decision = (dx >> 1);
             wCurx <= wNextx; wCurx++, wNextx--, decision += dy)
        {
            if (decision >= dx)
            {
                decision -= dx;
                wCury += y_sign;
                wNexty -= y_sign;
            }
            for (wpy = wCury - wWidth / 2;
                 wpy <= wCury + wWidth / 2; wpy++)
            {
                if (wCurx >= Rect.wLeft &&
                    wCurx <= Rect.wRight &&
                    wpy >= Rect.wTop &&
                    wpy <= Rect.wBottom)
                {
                    PlotPointView(wCurx, wpy, Color.uForeground);
                }
            }

            for (wpy = wNexty - wWidth / 2;
                 wpy <= wNexty + wWidth / 2; wpy++)
            {
                if (wNextx >= Rect.wLeft &&
                    wNextx <= Rect.wRight &&
                    wpy >= Rect.wTop &&
                    wpy <= Rect.wBottom)
                {
                    PlotPointView(wNextx, wpy, Color.uForeground);
                }
            }
        }
    }
    else
    {
        for (wCurx = wXStart, wCury = wYStart, wNextx = wXEnd,
                wNexty = wYEnd, decision = (dy >> 1);
            wCury <= wNexty; wCury++, wNexty--, decision += dx)
        {
            if (decision >= dy)
            {
                decision -= dy;
                wCurx += x_sign;
                wNextx -= x_sign;
            }
            for (wpx = wCurx - wWidth / 2;
                 wpx <= wCurx + wWidth / 2; wpx++)
            {
                if (wpx >= Rect.wLeft &&
                    wpx <= Rect.wRight &&
                    wCury >= Rect.wTop &&
                    wCury <= Rect.wBottom)
                {
                    PlotPointView(wpx, wCury, Color.uForeground);
                }
            }

            for (wpx = wNextx - wWidth / 2;
                 wpx <= wNextx + wWidth / 2; wpx++)
            {
                if (wpx >= Rect.wLeft &&
                    wpx <= Rect.wRight &&
                    wNexty >= Rect.wTop &&
                    wNexty <= Rect.wBottom)
                {
                    PlotPointView(wpx, wNexty, Color.uForeground);
                }
            }
        }
    }
}


/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
void S1D13A04Screen::HorizontalLine(SIGNED wXStart, SIGNED wXEnd, SIGNED wYPos,
    COLORVAL Color, SIGNED wWidth)
{
    UCHAR *Put;
    while(wWidth-- > 0)
    {
        Put = mpScanPointers[wYPos] + wXStart;

        // most compilers seem to do a good job of optimizing 
        // memset to do 32-bit data writes. If your compiler doesn't
        // make the most of your CPU, you might want to re-write this
        // in assembly.

        memset(Put, Color, wXEnd - wXStart + 1);
        wYPos++;
    }
}


/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
void S1D13A04Screen::VerticalLine(SIGNED wYStart, SIGNED wYEnd, SIGNED wXPos,
    COLORVAL Color, SIGNED wWidth)
{
    while(wYStart <= wYEnd)
    {
        SIGNED lWidth = wWidth;
        UCHAR *Put = mpScanPointers[wYStart] + wXPos;

        while (lWidth-- > 0)
        {
            *Put++ = (UCHAR) Color;
        }
        wYStart++;
    }
}


/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
void S1D13A04Screen::HorizontalLineXOR(SIGNED wXStart, SIGNED wXEnd, SIGNED wYPos)
{
    UCHAR *Put = mpScanPointers[wYPos] + wXStart;
    UCHAR uVal;

    while (wXStart <= wXEnd)
    {
        uVal = *Put;
        uVal ^= 0xf;
        *Put = uVal;
        Put += 2;
        wXStart += 2;
    }
}


/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
void S1D13A04Screen::VerticalLineXOR(SIGNED wYStart, SIGNED wYEnd, SIGNED wXPos)
{
    UCHAR uVal;

    while (wYStart <= wYEnd)
    {
        UCHAR *Put = mpScanPointers[wYStart] + wXPos;
        uVal = *Put;
        uVal ^= 0xf;
        *Put = uVal;
        wYStart += 2;
    }
}

/*--------------------------------------------------------------------------*/
void S1D13A04Screen::Capture(PegCapture *Info, PegRect &CaptureRect)
{
    PegBitmap *pMap = Info->Bitmap();

    if (CaptureRect.wLeft < 0)
    {
        CaptureRect.wLeft = 0;
    }

    if (CaptureRect.wTop < 0)
    {
        CaptureRect.wTop = 0;
    }

    Info->SetPos(CaptureRect);
    LONG Size = pMap->wWidth * pMap->wHeight;
    Info->Realloc(Size);

    UCHAR *GetStart = mpScanPointers[CaptureRect.wTop] + CaptureRect.wLeft;

    // make room for the memory bitmap:

    pMap->uFlags = 0;        // raw format

    // fill in the image with our captured info:

    UCHAR *Put = pMap->pStart;

    for (WORD wLine = 0; wLine < pMap->wHeight; wLine++)
    {
        UCHAR *Get = GetStart;

       #ifdef MEMCPY_NOT_SUPPORTED

        WORD wCount = pMap->wWidth;
        while(wCount--)
        {
            *Put++ = *Get++;
        }
       #else

        memcpy(Put, Get, pMap->wWidth);
        Put += pMap->wWidth;

       #endif

        GetStart += mwHRes;
    }
    Info->SetValid(TRUE);
}

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
void S1D13A04Screen::BitmapView(const PegPoint Where, const PegBitmap *Getmap,
    const PegRect &View)
{
    if (IS_RLE(Getmap))
    {
        DrawRleBitmap(Where, View, Getmap);
    }
    else
    {
        UCHAR *Get = Getmap->pStart;

        WORD wPitch = Getmap->wWidth;

        Get += (View.wTop - Where.y) * wPitch;
        Get += View.wLeft - Where.x;

        if (HAS_TRANS(Getmap))
        {
            for (SIGNED wLine = View.wTop; wLine <= View.wBottom; wLine++)
            {
                UCHAR *Put = mpScanPointers[wLine] + View.wLeft;
                for (SIGNED wLoop1 = View.wLeft; wLoop1 <= View.wRight; wLoop1++)
                {
                    UCHAR uVal = *Get++;
    
                    if (uVal != Getmap->dTransColor)
                    {
                        *Put = uVal;
                    }
                    Put++;
                }
                Get += wPitch - View.Width();
            }
        }
        else
        {
            WORD wWidth = View.Width();
            for (SIGNED wLine = View.wTop; wLine <= View.wBottom; wLine++)
            {
                UCHAR *Put = mpScanPointers[wLine] + View.wLeft;

               #ifdef MEMCPY_NOT_SUPPORTED

                WORD wCount = wWidth;
                while(wCount--)
                {
                    *Put++ = *Get++;
                }
                Get -= wWidth;

               #else

                memcpy(Put, Get, wWidth);

               #endif

                Get += wPitch;
            }
        }
    }
}

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
void S1D13A04Screen::DrawRleBitmap(const PegPoint Where, const PegRect View,
    const PegBitmap *Getmap)
{
    UCHAR *Get = Getmap->pStart;
    UCHAR uVal;
    SIGNED uCount;

    SIGNED wLine = Where.y;

    uCount = 0;

    while (wLine < View.wTop)
    {
        uCount = 0;

        while(uCount < Getmap->wWidth)
        {
            uVal = *Get++;
            if (uVal & 0x80)
            {
                uVal = (uVal & 0x7f) + 1;
                uCount += uVal;
                Get += uVal;
            }
            else
            {
                Get++;
                uCount += uVal + 1;
            }
        }
        wLine++;
    }

    if (HAS_TRANS(Getmap))
    {
	    while (wLine <= View.wBottom)
	    {
	        UCHAR *Put = mpScanPointers[wLine] + Where.x;
	        SIGNED wLoop1 = Where.x;
	
	        while (wLoop1 < Where.x + Getmap->wWidth)
	        {
	            uVal = *Get++;
	
	            if (uVal & 0x80)        // raw packet?
	            {
	                uCount = (uVal & 0x7f) + 1;
	                
	                while (uCount--)
	                {
	                    uVal = *Get++;
	                    if (wLoop1 >= View.wLeft &&
	                        wLoop1 <= View.wRight &&
	                        uVal != Getmap->dTransColor)
	                    {
	                        *Put = uVal;
	                    }
	                    Put++;
	                    wLoop1++;
	                }
	            }
	            else
	            {
	                uCount = uVal + 1;
	                uVal = *Get++;
	
	                if (uVal == Getmap->dTransColor)
	                {
	                    wLoop1 += uCount;
	                    Put += uCount;
	                }
	                else
	                {
	                    while(uCount--)
	                    {
	                        if (wLoop1 >= View.wLeft &&
	                            wLoop1 <= View.wRight)
	                        {
	                            *Put++ = uVal;
	                        }
	                        else
	                        {
	                            Put++;
	                        }
	                        wLoop1++;
	                    }
	                }
	            }
	        }
	        wLine++;
	    }
    }
    else
    {
	    while (wLine <= View.wBottom)
	    {
	        UCHAR *Put = mpScanPointers[wLine] + Where.x;
	        SIGNED wLoop1 = Where.x;
	
	        while (wLoop1 < Where.x + Getmap->wWidth)
	        {
	            uVal = *Get++;
	
	            if (uVal & 0x80)        // raw packet?
	            {
	                uCount = (uVal & 0x7f) + 1;
	                
	                while (uCount--)
	                {
	                    uVal = *Get++;
	                    if (wLoop1 >= View.wLeft &&
	                        wLoop1 <= View.wRight)
	                    {
	                        *Put = uVal;
	                    }
	                    Put++;
	                    wLoop1++;
	                }
	            }
	            else
	            {
	                uCount = uVal + 1;
	                uVal = *Get++;
	
                    while(uCount--)
                    {
                        if (wLoop1 >= View.wLeft &&
	                        wLoop1 <= View.wRight)
	                    {
	                        *Put++ = uVal;
	                    }
	                    else
	                    {
	                        Put++;
	                    }
	                    wLoop1++;
	                }
	            }
	        }
	        wLine++;
	    }
    }
}

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
void S1D13A04Screen::RectMoveView(PegThing *Caller, const PegRect &View,
     const SIGNED xMove, const SIGNED yMove)
{
    PegCapture tCapture;
    PegRect CaptureRect = View;
    Capture(&tCapture, CaptureRect);
    tCapture.Shift(xMove, yMove);
    Bitmap(Caller, tCapture.Point(), tCapture.Bitmap(), TRUE);
}

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
void S1D13A04Screen::DrawTextView(PegPoint Where, const PEGCHAR *Text, PegColor &Color,
    PegFont *Font, SIGNED iCount, PegRect &Rect)
{
   #ifdef PEG_UNICODE
    PEGCHAR PEGFAR *pCurrentChar = (PEGCHAR PEGFAR *) Text;
    PegFont *pFontStart = Font;
   #else
    UCHAR PEGFAR *pCurrentChar = (UCHAR PEGFAR *) Text;
   #endif

    UCHAR PEGFAR *pGetData;
    UCHAR PEGFAR *pGetDataBase;
    WORD  wIndex;
    WORD  wBitOffset;
    SIGNED  wXpos = Where.x;
    WORD cVal = *pCurrentChar++;
    SIGNED iCharWidth;

   #ifdef DO_OUTLINE_TEXT
    if (IS_OUTLINE(Font))
    {
        DrawOutlineText(Where, Text, Color, Font, iCount, Rect);
        return;
    }
   #endif

    while(cVal && wXpos <= Rect.wRight)
    {
        if (iCount == 0)
        {
            return;
        }
        iCount--;

       #ifdef PEG_UNICODE
        Font = pFontStart;

        while(Font)
        {
            if (cVal >= Font->wFirstChar &&
                cVal <= Font->wLastChar)
            {
                break;
            }
            Font = Font->pNext;
        }
        if (!Font)                 // this font doesn't contain this glyph?
        {
            cVal = *pCurrentChar++; // just skip to next char
            continue;               
        }

        wIndex = cVal - (WORD) Font->wFirstChar;

        if (IS_VARWIDTH(Font))
        {
            wBitOffset = Font->pOffsets[wIndex];
            iCharWidth = Font->pOffsets[wIndex+1] - wBitOffset;
        }
        else
        {
            iCharWidth = (SIGNED) Font->pOffsets;
            wBitOffset = iCharWidth * wIndex;
        }

       #else

        wIndex = cVal - (WORD) Font->wFirstChar;
        wBitOffset = Font->pOffsets[wIndex];
        iCharWidth = Font->pOffsets[wIndex+1] - wBitOffset;

       #endif

        if (wXpos + iCharWidth > Rect.wRight)
        {
            iCharWidth = Rect.wRight - wXpos + 1;
        }

        WORD ByteOffset = wBitOffset / 8;
        pGetDataBase = Font->pData + ByteOffset;
        pGetDataBase += (Rect.wTop - Where.y) * Font->wBytesPerLine;

        for (SIGNED ScanRow = Rect.wTop; ScanRow <= Rect.wBottom; ScanRow++)
        {
            pGetData = pGetDataBase;
            UCHAR InMask = 0x80 >> (wBitOffset & 7);
            WORD wBitsOutput = 0;
            UCHAR cData;

           #ifdef PEG_UNICODE
            if (ScanRow - Where.y < Font->uHeight)
            {
                cData = *pGetData++;
            }
            else
            {
                cData = 0;
            }
           #else
            cData = *pGetData++;
           #endif

            UCHAR *Put = mpScanPointers[ScanRow] + wXpos;

            while(wBitsOutput < iCharWidth)
            {
                if (!InMask)
                {
                    InMask = 0x80;
                    // read a byte:

                   #ifdef PEG_UNICODE
                    if (ScanRow - Where.y < Font->uHeight)
                    {
                        cData = *pGetData++;
                    }
                    else
                    {
                        cData = 0;
                    }
                   #else
                    cData = *pGetData++;
                   #endif
                }

                if (wXpos >= Rect.wLeft)
                {
                    if (cData & InMask)        // is this bit a 1?
                    {
                        *Put = (UCHAR) Color.uForeground;
                    }
                    else
                    {
                        if (Color.uFlags & CF_FILL)
                        {
                            *Put = (UCHAR) Color.uBackground;
                        }
                    }
                }
                InMask >>= 1;
                wXpos++;
                Put++;
                wBitsOutput++;
                if (wXpos > Rect.wRight)
                {
                    break;
                }
            }
            pGetDataBase += Font->wBytesPerLine;
            wXpos -= iCharWidth;
        }
        wXpos += iCharWidth;
        cVal = *pCurrentChar++;
    }
}


/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
void S1D13A04Screen::SetPalette(SIGNED iFirst, SIGNED iCount, 
                                const UCHAR *pGet)
{
    SIGNED iIndex = iFirst;
    UCHAR* pPut = mPalette;
    pPut += (iFirst * 3);
    memcpy(pPut, pGet, iCount * 3);

    for(SIGNED iLoop = 0; iLoop < iCount; iLoop++)
    {
        S1D_WRITE_PALETTE(mpVidRegBase, iIndex, *pGet, *(pGet + 1),
                          *(pGet + 2));
        iIndex++;
        pGet += 3;
    }
}

/*--------------------------------------------------------------------------*/
void S1D13A04Screen::HidePointer(void)
{
   #if defined(PEG_MOUSE_SUPPORT)
    if (mbShowPointer)
    {
        Restore(PegThing::Presentation(), &mCapture, TRUE);
        mCapture.SetValid(FALSE);
    }
   #endif
}

/*--------------------------------------------------------------------------*/
void S1D13A04Screen::SetPointer(PegPoint Where)
{
   #ifdef PEG_MOUSE_SUPPORT
    if (mbShowPointer)
    {
	    LOCK_PEG
	    HidePointer();
	    mLastPointerPos = Where;
	
	    Where.x -= miCurXOffset;
	    Where.y -= miCurYOffset;
	
	    PegRect MouseRect;
	    MouseRect.wLeft = Where.x;
	    MouseRect.wTop =  Where.y;
	    MouseRect.wBottom = MouseRect.wTop + mpCurPointer->wHeight - 1;
	    MouseRect.wRight = MouseRect.wLeft + mpCurPointer->wWidth - 1;

       #ifdef DOUBLE_BUFFER
		if(!miInvalidCount)
		{
			mInvalid = mCapture.Pos();
		}
       #endif

	    Capture(&mCapture, MouseRect);
	        
	    Bitmap(PegThing::Presentation(), Where, mpCurPointer, TRUE);

       #ifdef DOUBLE_BUFFER
		if(!miInvalidCount)
		{
			miInvalidCount = 1;
			mInvalid |= MouseRect;
			MemoryToScreen();
			miInvalidCount = 0;
		}
       #endif

	    UNLOCK_PEG
    }
   #endif   // MOUSE_SUPPORT ?
}

/*--------------------------------------------------------------------------*/
void S1D13A04Screen::SetPointerType(UCHAR bType)
{
   #ifdef PEG_MOUSE_SUPPORT
    if (bType < NUM_POINTER_TYPES)
    {
        LOCK_PEG
        HidePointer();

        mpCurPointer = mpPointers[bType].Bitmap;

        miCurXOffset = mpPointers[bType].xOffset;
        miCurYOffset = mpPointers[bType].yOffset;
        SetPointer(mLastPointerPos);

        UNLOCK_PEG
    }
   #endif   // MOUSE_SUPPORT?
}


/*--------------------------------------------------------------------------*/
void S1D13A04Screen::ResetPalette(void)
{
    SetPalette(0, 232, DefPalette256);
}


/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
UCHAR *S1D13A04Screen::GetPalette(DWORD *pPutSize)
{
    *pPutSize = 232;
    return mPalette;
}

/*--------------------------------------------------------------------------*/
void S1D13A04Screen::ConfigureController(void)
{
    WORD wIndex = 0;
    for(wIndex; wIndex < (sizeof(gaRegVals) / sizeof(gaRegVals[0])); wIndex++)
    {
        if(gaRegVals[wIndex].Index < S1D_REGRESERVED)
        {
            WriteVidReg(gaRegVals[wIndex].Index, gaRegVals[wIndex].Value);
        }
    }

    UCHAR* pPal;
    pPal = DefPalette256;
	for (wIndex = 0; wIndex < 256; wIndex++)
	{
        S1D_WRITE_PALETTE(mpVidRegBase, wIndex, *pPal, *(pPal + 1), 
                          *(pPal + 2));
        pPal+= 3;
	}

    // clear the screen:

    HorizontalLine(0, mwHRes - 1, 0, 0, mwVRes);
    
    #ifdef DOUBLE_BUFFER

    mInvalid.Set(0, 0, mwHRes - 1, mwVRes - 1);
    miInvalidCount = 1;
    MemoryToScreen();
    miInvalidCount = 0;

    #endif
}

/*--------------------------------------------------------------------------*/
void S1D13A04Screen::WriteVidReg(UCHAR ucIndex, DWORD dwValue)
{
    mpVidRegBase[ucIndex / gtSizeOfReg] = dwValue;
}

/*--------------------------------------------------------------------------*/
void S1D13A04Screen::WriteBlitReg(WORD wIndex, DWORD dwValue)
{
    mpBitBlitRegs[wIndex / gtSizeOfReg] = dwValue;
}

/*--------------------------------------------------------------------------*/
#ifdef DOUBLE_BUFFER

void S1D13A04Screen::MemoryToScreen(void)
{
	static const DWORD dwOffset = (mwHRes / sizeof(WORD)) & 0x7ff;

    // perform a system-to-screen or screen-screen bitblit:

    if (!miInvalidCount)
    {
        return;
    }

    PegRect Copy;
    Copy.Set(0, 0, mwHRes - 1, mwVRes - 1);
    Copy &= mInvalid;

    SIGNED iTop = Copy.wTop;
    SIGNED iLeft = Copy.wLeft;
    SIGNED iWidth = Copy.Width();

    if (iWidth <= 0)
    {
        return;
    }

    SIGNED iHeight = Copy.Height();
    if (iHeight <= 0)
    {
        return;
    }

    DWORD dSource = (DWORD) mpScanPointers[iTop] - (DWORD) mpVidMemBase;
    dSource += iLeft;
    DWORD dDest = dSource - (mwHRes * mwVRes);

    BLIT_CHECK

    WriteBlitReg(REG_BB_SRC_START_ADDR, (dSource & 0x1FFFFF));

    WriteBlitReg(REG_BB_DEST_START_ADDR, (dDest & 0x1FFFFF));

	WriteBlitReg(REG_BB_MEM_ADDR_OFFSET, dwOffset);

    WriteBlitReg(REG_BB_WIDTH, ((iWidth - 1) & 0x3ff));
    
    WriteBlitReg(REG_BB_HEIGHT, ((iHeight - 1) & 0x3ff));
     
    DWORD dwRegVal = 0x0c;
    dwRegVal <<= 16;
    if (dDest <= dSource)
    {
        dwRegVal |= 0x02;
    }
    else
    {
        dwRegVal |= 0x03;
    }
    
    WriteBlitReg(REG_BB_COMMAND, dwRegVal);

    WriteBlitReg(REG_BB_CONTROL, 0x01);
}

#endif

/*--------------------------------------------------------------------------*/
/*
$Workfile: 13a0scr8.cpp $
$Author: Ken $
$Date: 11/20/:2 12:43p $
$Revision: 4 $
$Log: /peg/source/13a0scr8.cpp $
// 
// 4     11/20/:2 12:43p Ken
// Improved line drawing routine.
// 
// 3     11/19/:2 3:09p Jarret
// 
// 2     11/15/:2 1:30p Jim
// Changed to GrayPalette to linear spaced.
// 
// 1     8/15/:2 4:25p Jim
// Initial checkin
*/
/*--------------------------------------------------------------------------*/

// End of file


